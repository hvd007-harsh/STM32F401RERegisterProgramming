C51 COMPILER V9.60.7.0   RFID                                                              10/29/2023 18:54:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RFID
OBJECT MODULE PLACED IN .\Objects\rfid.obj
COMPILER INVOKED BY: D:\C51\BIN\C51.EXE rfid.c OPTIMIZE(8,SPEED) BROWSE INCDIR(D:\MS51BSP_KEIL-master\MS51FB9AE_MS51XB9A
                    -E_MS51XB9BE\Library\Device\Include;D:\MS51BSP_KEIL-master\MS51FB9AE_MS51XB9AE_MS51XB9BE\Library\StdDriver\inc) DEBUG OBJ
                    -ECTEXTEND PRINT(.\Listings\rfid.lst) TABS(2) OBJECT(.\Objects\rfid.obj)

line level    source

   1          #include "rfid.h"
   2          #include "spi.h"
   3          
   4          #include "MS51_16K.H"
   5          
   6          
   7          void SPI_Tx(unsigned char Data);
   8          unsigned char SPI_Rx(unsigned char Rx_Buf);
   9          
  10           unsigned char  RC522_SPI_Transfer( unsigned char  Data)
  11          {
  12   1         unsigned char  rx_Data;
  13   1        
  14   1        SPI_Tx(Data);
  15   1        
  16   1        Timer0_Delay(16000000,200,100);            /* check delay.c*/
  17   1        
  18   1        SPI_Rx(rx_Data);
  19   1        
  20   1        Timer0_Delay(16000000,200,100);            /* check delay.c*/
  21   1        
  22   1        return rx_Data;
  23   1      }
  24          
  25          void Write_MFRC522( unsigned char  addr,  unsigned char  val) {
  26   1        /* CS LOW */
  27   1        P15= 0x00; 
  28   1        //The address is located:0XXXXXX0
  29   1        RC522_SPI_Transfer((addr << 1) & 0x7E);
  30   1        RC522_SPI_Transfer(val);
  31   1      
  32   1        /* CS HIGH */
  33   1        P15 = 0xFF; 
  34   1      }
  35          
  36           unsigned char  Read_MFRC522( unsigned char  addr) {
  37   1        unsigned char  val;
  38   1      
  39   1        /* CS LOW */
  40   1        P15 = 0x00;
  41   1      
  42   1        //The address is located:1XXXXXX0
  43   1        RC522_SPI_Transfer(((addr << 1) & 0x7E) | 0x80);
  44   1        val = RC522_SPI_Transfer(0x00);
  45   1      
  46   1        /* CS HIGH */
  47   1        P15 = 0xFF;
  48   1        return val;
  49   1      
  50   1      }
  51          
  52          void SetBitMask( unsigned char  reg,  unsigned char  mask) {
  53   1         unsigned char  tmp;
C51 COMPILER V9.60.7.0   RFID                                                              10/29/2023 18:54:13 PAGE 2   

  54   1        tmp = Read_MFRC522(reg);
  55   1        Write_MFRC522(reg, tmp | mask);  // set bit mask
  56   1      }
  57          
  58          void ClearBitMask( unsigned char  reg,  unsigned char  mask) {
  59   1         unsigned char  tmp;
  60   1        tmp = Read_MFRC522(reg);
  61   1        Write_MFRC522(reg, tmp & (~mask));  // clear bit mask
  62   1      }
  63          
  64          void AntennaOn(void) {
  65   1      
  66   1        Read_MFRC522(TxControlReg);
  67   1      
  68   1        SetBitMask(TxControlReg, 0x03);
  69   1      }
  70          
  71          void AntennaOff(void) {
  72   1        ClearBitMask(TxControlReg, 0x03);
  73   1      }
  74          
  75          void MFRC522_Reset(void) {
  76   1        Write_MFRC522(CommandReg, PCD_RESETPHASE);
  77   1      }
  78          
  79          void MFRC522_Init(void) {
  80   1      
  81   1        //GPIO_SetBits(MFRC522_CS_GPIO,MFRC522_CS_PIN);           // Activate the RFID reader
  82   1        P15 = 0x00;
  83   1        P17 = 0xFF;
  84   1        //GPIO_SetBits(MFRC522_RST_GPIO,MFRC522_RST_PIN);         // not reset
  85   1      
  86   1        // spi config
  87   1        //MFRC522_SPI_Init();
  88   1      
  89   1        MFRC522_Reset();
  90   1      
  91   1        //Timer: TPrescaler*TreloadVal/6.78MHz = 24ms
  92   1        Write_MFRC522(TModeReg, 0x8D);    //auto=1; f(Timer) = 6.78MHz/TPreScaler
  93   1        Write_MFRC522(TPrescalerReg, 0x3E); //TModeReg[3..0] + TPrescalerReg
  94   1        Write_MFRC522(TReloadRegL, 30);
  95   1        Write_MFRC522(TReloadRegH, 0);
  96   1      
  97   1        Write_MFRC522(TxAutoReg, 0x40);   //100%ASK
  98   1        Write_MFRC522(ModeReg, 0x3D);   //CRC Original value 0x6363 ???
  99   1      
 100   1        //ClearBitMask(Status2Reg, 0x08);   //MFCrypto1On=0
 101   1        //Write_MFRC522(RxSelReg, 0x86);    //RxWait = RxSelReg[5..0]
 102   1        //Write_MFRC522(RFCfgReg, 0x7F);      //RxGain = 48dB
 103   1      
 104   1        AntennaOn();    //Mo Anten
 105   1      }
 106          
 107           unsigned char  MFRC522_ToCard( unsigned char  command,  unsigned char  *sendData,  unsigned char  sendLen
             -,  unsigned char  *backData,  unsigned int  *backLen)
 108          {
 109   1         unsigned char  status = MI_ERR;
 110   1         unsigned char  irqEn = 0x00;
 111   1         unsigned char  waitIRq = 0x00;
 112   1         unsigned char  lastBits;
 113   1         unsigned char  n;
 114   1         unsigned int  i;
C51 COMPILER V9.60.7.0   RFID                                                              10/29/2023 18:54:13 PAGE 3   

 115   1      
 116   1        switch (command) {
 117   2        case PCD_AUTHENT:   //Acknowledging the liver
 118   2        {
 119   3          irqEn = 0x12;
 120   3          waitIRq = 0x10;
 121   3          break;
 122   3        }
 123   2        case PCD_TRANSCEIVE:  // FIFO Data collection
 124   2        {
 125   3          irqEn = 0x77;
 126   3          waitIRq = 0x30;
 127   3          break;
 128   3        }
 129   2        default:
 130   2          break;
 131   2        }
 132   1      
 133   1        Write_MFRC522(CommIEnReg, irqEn | 0x80);  //Yeu cau ngat
 134   1        ClearBitMask(CommIrqReg, 0x80);     //Clear all the bits
 135   1        SetBitMask(FIFOLevelReg, 0x80);     //FlushBuffer=1, FIFO
 136   1      
 137   1        Write_MFRC522(CommandReg, PCD_IDLE);//NO action; Huy bo lenh hien hanh  ???
 138   1      
 139   1        // Record in FIFO
 140   1        for (i = 0; i < sendLen; i++) {
 141   2          Write_MFRC522(FIFODataReg, sendData[i]);
 142   2        }
 143   1      
 144   1        //chay
 145   1        Write_MFRC522(CommandReg, command);
 146   1        if (command == PCD_TRANSCEIVE) {
 147   2          SetBitMask(BitFramingReg, 0x80);//StartSend=1,transmission of Data starts  
 148   2        }
 149   1      
 150   1        //The team is allowed to be stored
 151   1        i = 2000;//i tuy thuoc tan so thach anh, thoi gian toi da cho the M1 la 25ms
 152   1        do {
 153   2          //CommIrqReg[7..0]
 154   2          //Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq
 155   2          n = Read_MFRC522(CommIrqReg);
 156   2          i--;
 157   2        } while ((i != 0) && !(n & 0x01) && !(n & waitIRq));
 158   1      
 159   1        ClearBitMask(BitFramingReg, 0x80);      //StartSend=0
 160   1      
 161   1        if (i != 0) {
 162   2          if (!(Read_MFRC522(ErrorReg) & 0x1B))//BufferOvfl Collerr CRCErr ProtecolErr
 163   2          {
 164   3            status = MI_OK;
 165   3            if (n & irqEn & 0x01) {
 166   4              status = MI_NOTAGERR;     //??   
 167   4            }
 168   3      
 169   3            if (command == PCD_TRANSCEIVE) {
 170   4              n = Read_MFRC522(FIFOLevelReg);
 171   4              lastBits = Read_MFRC522(ControlReg) & 0x07;
 172   4              if (lastBits) {
 173   5                *backLen = (n - 1) * 8 + lastBits;
 174   5              } else {
 175   5                *backLen = n * 8;
 176   5              }
C51 COMPILER V9.60.7.0   RFID                                                              10/29/2023 18:54:13 PAGE 4   

 177   4      
 178   4              if (n == 0) {
 179   5                n = 1;
 180   5              }
 181   4              if (n > MAX_LEN) {
 182   5                n = MAX_LEN;
 183   5              }
 184   4      
 185   4              //FIFO doc in the received Data
 186   4              for (i = 0; i < n; i++) {
 187   5                backData[i] = Read_MFRC522(FIFODataReg);
 188   5              }
 189   4            }
 190   3          } else {
 191   3            status = MI_ERR;
 192   3          }
 193   2      
 194   2        }
 195   1      
 196   1        //SetBitMask(ControlReg,0x80);           //timer stops
 197   1        //Write_MFRC522(CommandReg, PCD_IDLE); 
 198   1      
 199   1        return status;
 200   1      }
 201          
 202           unsigned char  MFRC522_Request( unsigned char  reqMode,  unsigned char  *TagType) {
 203   1         unsigned char  status;
 204   1         unsigned int  backBits;      //The bits are manipulated
 205   1      
 206   1        Write_MFRC522(BitFramingReg, 0x07); //TxLastBists = BitFramingReg[2..0] ???
 207   1      
 208   1        TagType[0] = reqMode;
 209   1        status = MFRC522_ToCard(PCD_TRANSCEIVE, TagType, 1, TagType, &backBits);
 210   1      
 211   1        if ((status != MI_OK) || (backBits != 0x10)) {
 212   2          status = MI_ERR;
 213   2        }
 214   1      
 215   1        return status;
 216   1      }
 217          
 218           unsigned char  MFRC522_Anticoll( unsigned char  *serNum) {
 219   1         unsigned char  status;
 220   1         unsigned char  i;
 221   1         unsigned char  serNumCheck = 0;
 222   1         unsigned int  unLen;
 223   1      
 224   1        //ClearBitMask(Status2Reg, 0x08);   //TempSensclear
 225   1        //ClearBitMask(CollReg,0x80);     //ValuesAfterColl
 226   1        Write_MFRC522(BitFramingReg, 0x00);   //TxLastBists = BitFramingReg[2..0]
 227   1      
 228   1        serNum[0] = PICC_ANTICOLL;
 229   1        serNum[1] = 0x20;
 230   1        status = MFRC522_ToCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);
 231   1      
 232   1        if (status == MI_OK) {
 233   2          //Check the serial number
 234   2          for (i = 0; i < 4; i++) {
 235   3            serNumCheck ^= serNum[i];
 236   3          }
 237   2          if (serNumCheck != serNum[i]) {
 238   3            status = MI_ERR;
C51 COMPILER V9.60.7.0   RFID                                                              10/29/2023 18:54:13 PAGE 5   

 239   3          }
 240   2        }
 241   1      
 242   1        //SetBitMask(CollReg, 0x80);    //ValuesAfterColl=1
 243   1      
 244   1        return status;
 245   1      }
 246          
 247          void CalulateCRC( unsigned char  *pInData,  unsigned char  len,  unsigned char  *pOutData) {
 248   1         unsigned char  i, n;
 249   1      
 250   1        ClearBitMask(DivIrqReg, 0x04);      //CRCIrq = 0
 251   1        SetBitMask(FIFOLevelReg, 0x80);     //Con tro FIFO
 252   1        //Write_MFRC522(CommandReg, PCD_IDLE);
 253   1      
 254   1        //Record in FIFO
 255   1        for (i = 0; i < len; i++) {
 256   2          Write_MFRC522(FIFODataReg, *(pInData + i));
 257   2        }
 258   1        Write_MFRC522(CommandReg, PCD_CALCCRC);
 259   1      
 260   1        // Let the CRC computer complete
 261   1        i = 0xFF;
 262   1        do {
 263   2          n = Read_MFRC522(DivIrqReg);
 264   2          i--;
 265   2        } while ((i != 0) && !(n & 0x04));      //CRCIrq = 1
 266   1      
 267   1        //Doc results in CRC calculation
 268   1        pOutData[0] = Read_MFRC522(CRCResultRegL);
 269   1        pOutData[1] = Read_MFRC522(CRCResultRegM);
 270   1      }
 271          
 272           unsigned char  MFRC522_SelectTag( unsigned char  *serNum) {
 273   1         unsigned char  i;
 274   1         unsigned char  status;
 275   1         unsigned char  size;
 276   1         unsigned int  recvBits;
 277   1         unsigned char  buffer[9];
 278   1      
 279   1        //ClearBitMask(Status2Reg, 0x08);     //MFCrypto1On=0
 280   1      
 281   1        buffer[0] = PICC_SElECTTAG;
 282   1        buffer[1] = 0x70;
 283   1        for (i = 0; i < 5; i++) {
 284   2          buffer[i + 2] = *(serNum + i);
 285   2        }
 286   1        CalulateCRC(buffer, 7, &buffer[7]);   //??
 287   1        status = MFRC522_ToCard(PCD_TRANSCEIVE, buffer, 9, buffer, &recvBits);
 288   1      
 289   1        if ((status == MI_OK) && (recvBits == 0x18)) {
 290   2          size = buffer[0];
 291   2        } else {
 292   2          size = 0;
 293   2        }
 294   1      
 295   1        return size;
 296   1      }
 297          
 298           unsigned char  MFRC522_Auth( unsigned char  authMode,  unsigned char  BlockAddr,  unsigned char  *Sectork
             -ey,
 299             unsigned char  *serNum) {
C51 COMPILER V9.60.7.0   RFID                                                              10/29/2023 18:54:13 PAGE 6   

 300   1         unsigned char  status;
 301   1         unsigned int  recvBits;
 302   1         unsigned char  i;
 303   1         unsigned char  buff[12];
 304   1      
 305   1        //Confirmation + Address + password + quick number
 306   1        buff[0] = authMode;
 307   1        buff[1] = BlockAddr;
 308   1        for (i = 0; i < 6; i++) {
 309   2          buff[i + 2] = *(Sectorkey + i);
 310   2        }
 311   1        for (i = 0; i < 4; i++) {
 312   2          buff[i + 8] = *(serNum + i);
 313   2        }
 314   1        status = MFRC522_ToCard(PCD_AUTHENT, buff, 12, buff, &recvBits);
 315   1      
 316   1        if ((status != MI_OK) || (!(Read_MFRC522(Status2Reg) & 0x08))) {
 317   2          status = MI_ERR;
 318   2        }
 319   1      
 320   1        return status;
 321   1      }
 322          
 323           unsigned char  MFRC522_Read( unsigned char  blockAddr,  unsigned char  *recvData) {
 324   1         unsigned char  status;
 325   1         unsigned int  unLen;
 326   1      
 327   1        recvData[0] = PICC_READ;
 328   1        recvData[1] = blockAddr;
 329   1        CalulateCRC(recvData, 2, &recvData[2]);
 330   1        status = MFRC522_ToCard(PCD_TRANSCEIVE, recvData, 4, recvData, &unLen);
 331   1      
 332   1        if ((status != MI_OK) || (unLen != 0x90)) {
 333   2          status = MI_ERR;
 334   2        }
 335   1      
 336   1        return status;
 337   1      }
 338          
 339           unsigned char  MFRC522_Write( unsigned char  blockAddr,  unsigned char  *writeData) {
 340   1         unsigned char  status;
 341   1         unsigned int  recvBits;
 342   1         unsigned char  i;
 343   1         unsigned char  buff[18];
 344   1      
 345   1        buff[0] = PICC_WRITE;
 346   1        buff[1] = blockAddr;
 347   1        CalulateCRC(buff, 2, &buff[2]);
 348   1        status = MFRC522_ToCard(PCD_TRANSCEIVE, buff, 4, buff, &recvBits);
 349   1      
 350   1        if ((status != MI_OK) || (recvBits != 4) || ((buff[0] & 0x0F) != 0x0A)) {
 351   2          status = MI_ERR;
 352   2        }
 353   1      
 354   1        if (status == MI_OK) {
 355   2          for (i = 0; i < 16; i++)    //16 FIFO bytes recorded
 356   2              {
 357   3            buff[i] = *(writeData + i);
 358   3          }
 359   2          CalulateCRC(buff, 16, &buff[16]);
 360   2          status = MFRC522_ToCard(PCD_TRANSCEIVE, buff, 18, buff, &recvBits);
 361   2      
C51 COMPILER V9.60.7.0   RFID                                                              10/29/2023 18:54:13 PAGE 7   

 362   2          if ((status != MI_OK) || (recvBits != 4)
 363   2              || ((buff[0] & 0x0F) != 0x0A)) {
 364   3            status = MI_ERR;
 365   3          }
 366   2        }
 367   1      
 368   1        return status;
 369   1      }
 370          
 371          void MFRC522_Halt(void) {
 372   1         unsigned int  unLen;
 373   1         unsigned char  buff[4];
 374   1      
 375   1        buff[0] = PICC_HALT;
 376   1        buff[1] = 0;
 377   1        CalulateCRC(buff, 2, &buff[2]);
 378   1      
 379   1        MFRC522_ToCard(PCD_TRANSCEIVE, buff, 4, buff, &unLen);
 380   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1401    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----     115
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
